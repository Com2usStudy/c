## 배열, 포인터에 대해 설명하시오

### 포인터

[[C언어]]에서 모든 변수는 *데이터가 저장되는 공간의 주소*를 가지고 있다. 그 `주소` 를 표현하는 방법은 다음과 같다.

```c
int B = 4; // B에 4 할당
int *A = &B; // B의 주소(&B) 를 포인터 *A 에 할당
```

이렇게 데이터의 주소를 저장하는 변수를 `포인터 변수` 라고 한다.

#### 포인터 주소의 크기

`포인터`에 저장되는 주소의 크기는 `시스템` 환경에 따라 다르다. `메모리` 에 있는 `byte` 를 모두 참조할 수 있어야 하는데, 이는 `운영체제` 의 구조(아키텍처)에 달려있다.

##### 아키텍처에 따른 메모리 주소의 크기

`x64` 운영체제라면 주소 크기가 `64 bit` 이며 따라서 메모리에서 `2^64` 개의 주소를 표현할 수 있다. 즉 `2^64 bytes` 크기의 메모리를 탐색할 수 있다. 따라서 `64 bit(=8 byte)` 가 `주소의 크기` 가 된다.
만약 주소의 크기로 `32bit` 를 사용하는 운영체제라면 `2^32 bytes` 크기의 메모리의 주소를 참조할 수 있다. 어떻게 고작 `32bit` 로 `2^32(=4,294,967,296) bytes` 만큼의 메모리를 커버 할 수 있는가가 궁금하다면 `메모리`는 `byte` 단위로 구성된다는 것을 상기해보자. `4,294,967,296 bytes` 메모리라는 것은 `byte` 라는 공간이 `4,294,967,296` 개 있다는 것이다. 즉 약 `40억 개` 의 공간에 번호를 부여하면 참조가 가능하다. 따라서 `32bit(=2^32 bit)(최대 4,294,967,296 까지 표현 가능)` 로도 `4GB` 메모리를 참조할 수 있는 것이다.
반면에 `64bit` 로는 `17,179,896,184 GB` 의 메모리까지 주소를 부여할 수 있다.

#### 포인터의 문법

포인터의 문법은 생각보다 단순하다. 
1. `int *A` : 포인터를 정의 할 때 사용되는 `*` (포인터 표시자)
2. `&B` : 데이터의 주소를 나타낼 때 사용되는 `&` (주소 값)
3. `*A` : 포인터가 가리키는 데이터를 나타낼 때 사용되는 `*` (간접 참조 연산자)

#### 포인터의 타입

`포인터`의 `타입`은 **포인터가 담을 데이터의 타입**과 동일해야 한다. 포인터의 타입은 `다음 주소` 를 결정하기도 한다. 다음과 같은 코드를 통해 그 동작을 확인할 수 있다.

```c
#include <stdio.h>

int main()
{
	int a = 10;
	int* ptr = &a;

	printf("%p\n", ptr); // 00000...B44
	printf("%p\n", (ptr + 1)); // 0 00000...B48 (4 증가!)
}
```

`int` 데이터를 가리키는 포인터에 1을 더하니 주소 값이 `1` 이 아니라 `4` 가 증가했다. `int` 는 `4bytes` 이므로 `ptr` 이 원래 가리키고 있는 주소에서 다음 `int` 데이터의 주소는 `4bytes` 가 더해진 값이 되기 때문이다.

### 배열

[[C언어]]에서 배열을 담은 변수는 **배열의 첫 번째 요소를 가리키는 포인터** 이다. 

![Alt text](<img/Pasted image 20231019134014.png>)

```c
int a[5] = {5, 3, 1, 2, 4};
```

위와 같이 `a` 배열이 선언됐다면, `a` 라는 변수는 `a[0]` 의 주소를 갖고 있는 것이다. 포인터에 `1` 을 더하면 자료형 크기 만큼 주소가 더해지므로, `&a[0] + 1` 은 `a[0]` 의 주소에서 다음 주소 값은 `a[1]` 을 가리키게 된다. 이해를 위해 다음 코드를 확인해보자.

```c
#include <stdio.h>

int main()
{
	int a[5] = { 5, 3, 1, 2, 4 };

	printf("%p\n", a); // 0번지
	printf("%p\n", a + 1); // 4번지
	printf("%p\n", &a[0] + 1); // 4번지
	printf("%d\n", *(a + 1)); // 3 출력
}
```

![Alt text](<img/Pasted image 20231019134711.png>)

결과 값은 위와 같다. 정말 `a` 라는 배열이 특정한 주소를 가리키고 있는 것을 확인할 수 있다. 또 다음 주소는 `4 byte` 가 증가된 값으로 `58 -> 5C` 가 됐다.

#### 배열과 포인터의 차이

`배열` 이 결국 `포인터` 라면, `배열` 과 `포인터` 의 차이는 뭘까? 차이가 더 많이 있을 수는 있겠지만, 현재로선 다음과 같이 `크기` 에 차이가 있다고 할 수 있겠다.

```c hl:13-15
#include <stdio.h>

int main()
{
	int a[5] = { 5, 3, 1, 2, 4 };

	int* ptr = &a[0];

	printf("%p\n", a); // 값이 모두 똑같다.
	printf("%p\n", &a[0]); // 값이 모두 똑같다.
	printf("%p\n", ptr); // 값이 모두 똑같다.

	printf("%d\n", sizeof(a)); // 4 bytes * 5 bytes = 20 bytes
	printf("%d\n", sizeof(a[0])); // 4 bytes
	printf("%d\n", sizeof(ptr)); // 8 bytes (x64 운영체제)
}
```

![Alt text](<img/Pasted image 20231019135033.png>)

실제로 `배열 a`  와 포인터 `ptr` 이 가리키는 값은 똑같지만, [[sizeof()]]로 확인해보면 크기가 다르다는 것을 확인할 수 있다.

## 다음 기능을 하는 함수를 만드시오.

1. 주소가 매개변수로 들어온 두 개의 정수의 값을 바꾸는 기능
2. 프로토타입 `void fn_swap(int *a, int *b)`

```c
#include <unistd.h>

char *charValue(int a)
{
    char buffer[12];
    char *ptr = &buffer[11];
    *ptr = '\0';

    if (a == 0)
    {
        --ptr;
        *ptr = '0';
    }
    else 
    {
        int is_negative = a < 0;
        if (is_negative)
        {
            a = -a;
        }

        while (a)
        {
            --ptr;
            *ptr = '0' + (a % 10);
            a /= 10;
        }

        if (is_negative)
        {
            --ptr;
            *ptr = '-';
        }
    }

    return ptr;
}

// 정수 크기 구하는 함수
int getLength(int a)
{
    int length = 0;
    if (a == 0)
    {
        length = 1;
    }
    while (a)
    {
        length += 1;
        a /= 10;
    }

    return length;
}


/*
내가 짠 값 바꾸는 함수 
C는 call by value 이다.
*/
void fn_swap(int *a, int *b)
{
    int temp = *a;
    *a = *b;
    *b = temp;
}

int main()
{

    int a = 10;
    int b = 20;

    fn_swap(&a, &b);

    write(1, charValue(a), getLength(a));
    write(1, "\n", 1);
    write(1, charValue(b), getLength(b));
    write(1, "\n", 1);
}
```

### Call By Value

```c
int func(int a, int b)
{
	int temp = a;
	a = b;
	b = temp;

	return 1;
}

int main()
{
	int a = 10;
	int b = 20;

	func(a, b); // 값 바꾸자! ... 실패!!
}
```

값 두 개를 받아 서로의 값을 교환하는 함수를 만들어보자. 위 `func()` 함수는 잘 동작할까? 결론적으론 의도대로 동작하지 않는다. 왜냐하면 [[C언어]]의 함수는 `Call By Value` 방식으로 인자를 받기 때문이다. `Call By Value` 방식은 `인자` 를 전달 받을 때 `인자` 의 `주소` 가 **아니라** `인자` 의 `값` 을 받아온다. 따라서 **func의 a, b와 main의 a, b는 다른 주소를 가리키고, 즉 다른 값을 말한다!** 따라서 `func()` 에서 `main()` 함수의 `a, b` 를 가리킬 수 없게 된다.
이 문제를 해결하기 위해서 `포인터` 를 활용할 수 있다.

```c hl:1,3-5
int func(int* a, int* b)
{
	int temp = *a;
	*a = *b;
	*b = temp;

	return 1;
}

int main()
{
	int a = 10;
	int b = 20;

	func(a, b); // 값 바꾸기 성공!
}
```

위 코드와 같이 `1번 줄` 에서 `포인터` 를 매개변수로 받을 수 있다. `포인터` 는 주소를 가리키므로, `Call By Value` 방식이긴 하지만, `Call By Reference` 방식처럼 동작할 수 있다. 즉 `main()` 함수에서 정의한 `a` 와 `b` 를 `func()` 함수에서도 가리킬 수 있게 됐다.

### 코드 설명

`ssize_t write(int fd, const void *buf, size_t count);` 함수는 출력할 파일을 읽고, 버퍼의 첫 주소를 넣고, 버퍼에서 `몇 byte` 를 읽을지 판별하는 인자를 주면서 사용한다. 즉 `printf()` 같은 함수와 같이 그냥 숫자를 출력할 수는 없다.

#### write() 의 동작

```c
    int c = 100;
    write(1, &c, sizeof(c)); // d 출력
    write(1, "\n", 1);
```

위와 같은 코드는 잘 동작한다. 즉 `int` 인 값 `100` 이 `메모리` 를 차지하고, `write()` 의 인자로 `&c` 가 전달된다. 그런데 우리는 `100` 을 출력하고 싶은데, 결과는 `d` 가 될 것이다. 그 이유는 `100` 이라는 값이 들어간 메모리를 `표준 출력` 으로 참조할 때 `ASCII` 값으로 읽어들이기 때문이다. 따라서 `ASCII` 값 `100` 인 `d` 가 출력된다.

#### charValue()

```c hl:3,4,5,23,24
char *charValue(int a)
{
    char buffer[12];
    char *ptr = &buffer[11];
    *ptr = '\0';

    if (a == 0) // 숫자가 0일 경우 처리
    {
        --ptr;
        *ptr = '0';
    }
    else 
    {
	    // 음수 처리
        int is_negative = a < 0;
        if (is_negative)
        {
            a = -a;
        }

        while (a)
        {
            --ptr;
            *ptr = '0' + (a % 10);
            a /= 10;
        }

        if (is_negative)
        {
            --ptr;
            *ptr = '-';
        }
    }

    return ptr;
}
```

`write()` 의 동작을 알았으니 이제 `int` 값을 그대로 출력하기 위한 함수를 만들어보자. `charValue()` 함수를 통해서 특정 공간에 `정수` 의 자리 수를 그대로 문자 처럼 넣어줄 수 있다. 즉 `100` 이라는 값을 `메모리` 에 저장한다면 문자 `'d'` 가 되지만, `'1'`, `'0'`, `'0'` 으로 만들어주면 `char` 형 `3 byte` 를 읽어서 `"100"` 이라는 문자열을 출력할 수 있게 된다.
`charValue()` 함수는 정수를 자리별로 잘라서 각각 `char` 로 만들어 배열 공간에 저장하는 함수다. 이 함수에 대해서 설명한다.
`3번줄` 에서 버퍼를 만들어 `정수` 를 `문자` 로 저장할 공간을 만든다. `int` 의 자리수는 `10자리` 까지 이므로, `음수 부호`와 `널 문자` 를 고려해서 `12 자리` 로 만들어줬다.
`'1'`, `'0'`, `'0'` 을 저장해야 한다면, 오른쪽부터 `'0'`, `'0'`, `'1'` 순으로 입력해야 하므로, `포인터` 를 `buffer` 배열의 맨 뒤에서부터 `왼쪽으로` 이동하도록 한다. 따라서 `4번줄` 에서 포인터의 주소를 `배열의 맨 뒤` 로 초기화한다.
`C` 언어에서 문자열의 끝은 `\0(널 문자)` 로 표현한다. 따라서 문자열의 마지막을 `\0` 으로 표현한다.
`5번줄` 에서 그 `널 문자` 를 넣어주고 있다.
`23번줄` 에서 정수의 매 `자리수` 마다 포인터를 한 자리씩 앞으로 이동해서 넣어준다. 숫자 `123` 에서 `3` 을 넣어줬다면, 다음으론 `2` 를 넣어줄 자리로 포인터를 이동한다는 것이다.
`24번줄` 에선 `'0'(ASCII 코드값)` 에 정수의 `자리수` 를 더해줌으로써 정수의 각 자리 값의 `ASCII 값` 을 얻는다. 이후 그 값을 포인터가 가리키는 자리에 할당한다.